model EMMR_prima_soluzione
uses "mmxprs", "mmsystem"
parameters 
	n = 15			! Scegliamo noi n siti e p hub
    p = 10
end-parameters    

declarations
	N = {1..n}							! Insieme dei siti da 1 a n
    w_ij: array(N,N) of real            ! Numero di oggetti da trasportare da i a j
    c_ijkm: array(N,N,N,N) of real      ! Costo di trasporto un unità prodotto da i a j attraverso k e m in quest'ordine
    x_ik: array(N,N) of mpvar    		! Variabili binarie per l'assegnazione dei siti agli hub, 1 assegnato 0 non assegnato
    S_i: array(N) of mpvar      		! Costi complessivi di trasporto da/per i per/da ogni j con j>i 
    C_ijkm: array(N,N,N,N) of real 		! Costi di trasporto totale tra siti i e j
end-declarations

initializations from "valori_"+n+".dat"
    w_ij
    c_ijkm
end-initializations

! Definizione delle C_ijkm

forall(i in N, j in N, k in N, m in N) do
    C_ijkm(i,j,k,m) := (w_ij(i,j)*c_ijkm(i,j,k,m)) + (w_ij(j,i)*c_ijkm(j,i,m,k))
end-do

! Vincolo (2)
sum(k in N) x_ik(k,k) = p

! Vincolo (3)
forall(i in N, k in N | i <> k) do
    x_ik(i,k) <= x_ik(k,k)
end-do

! Vincolo (4)
forall(i in N) do
    sum(k in N) (x_ik(i,k)) = 1
end-do

! Vincolo (5)
forall(i in N, k in N) do
    x_ik(i,k) <= 1       !Rilassamento vincolo binarietà
end-do

! Vincolo (7)
forall(i in N, k in N) do
    S_i(i) >= sum(j in N | j > i, m in N) (C_ijkm(i,j,k,m) * (x_ik(i,k) + x_ik(j,m) - 1))
end-do

forall(i in N) do
    S_i(i) >= 0
end-do

! Definizione della funzione obiettivo
obb := sum(i in N) (S_i(i))

! Definizione tempo massimo
setparam("XPRS_MAXTIME", 60)

start_time:=time(SYS_NOW)
! Ricerca locale per migliorare la soluzione
! Primo ciclo per hub
flag := 1
while (flag = 1) do
    flag := 0
    minimize(obb)
    imax:=0
 	kmax:=0 
 	currentmax:= 0.0
    forall(i in N)do 
 		!codice che fissa a 0 e 1 le variabili che dopo il primo minimize sono gia' a 0 o 1
		if(getsol(x_ik(i,i))=0) then 
			x_ik(i,i)=0
		end-if
		if(getsol(x_ik(i,i))=1) then
			x_ik(i,i)=1
		end-if
		!codice che cerca le variabili continue con valore massimo per fissarle ad 1
		if(getsol(x_ik(i,i))>0 and getsol(x_ik(i,i))<1)then 
			flag:=1
			if(currentmax<getsol(x_ik(i,i))) then
				currentmax:=getsol(x_ik(i,i))
				imax:=i
			end-if
	 	end-if
	end-do
	if (flag=1) then
		x_ik(imax,imax)=1
	end-if
end-do

! Secondo ciclo per siti
flag := 1
while (flag = 1) do
    flag := 0
    minimize(obb)
    imax:=0
 	kmax:=0 
 	currentmax:= 0.0
    forall(i in N, k in N | i <> k)do 
 		!codice che fissa a 0 e 1 le variabili che dopo il primo minimize sono gia' a 0 o 1
		if(getsol(x_ik(i,k))=0) then 
			x_ik(i,k)=0
		end-if
		if(getsol(x_ik(i,k))=1) then
			x_ik(i,k)=1
		end-if
		!codice che cerca le variabili continue con valore massimo per fissarle ad 1
		if(getsol(x_ik(i,k))>0 and getsol(x_ik(i,k))<1)then 
			flag:=1
			if (getsol(x_ik(k,k))=1) then
				if(currentmax<getsol(x_ik(i,k))) then
					currentmax:=getsol(x_ik(i,k))
					imax:=i
					kmax:=k
				end-if
			end-if
	 	end-if
	end-do
	if (flag=1) then
		x_ik(imax,kmax)=1
	end-if
end-do

end_time:= time(SYS_NOW) 
writeln(" run time= ",end_time-start_time," ms ")
writeln(" la FO vale ", getobjval ) 
end-model
