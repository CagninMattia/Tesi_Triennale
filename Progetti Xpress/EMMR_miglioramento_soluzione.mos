model EMMR_miglioramento_soluzione
uses "mmxprs", "mmsystem"
parameters 
	n = 50			! Scegliamo noi n siti e p hub
    p = 10
end-parameters    

declarations
	N = {1..n}							! Insieme dei siti da 1 a n
    w_ij: array(N,N) of real            ! Numero di oggetti da trasportare da i a j
    c_ijkm: array(N,N,N,N) of real      ! Costo di trasporto un unità prodotto da i a j attraverso k e m in quest'ordine
    x_ik: array(N,N) of mpvar    		! Variabili binarie per l'assegnazione dei siti agli hub, 1 assegnato 0 non assegnato
    S_i: array(N) of mpvar      		! Costi complessivi di trasporto da/per i per/da ogni j con j>i 
    C_ijkm: array(N,N,N,N) of real 		! Costi di trasporto totale tra siti i e j
end-declarations

initializations from "valori_"+n+".dat"
    w_ij
    c_ijkm
end-initializations

! Definizione delle C_ijkm

forall(i in N, j in N, k in N, m in N) do
    C_ijkm(i,j,k,m) := (w_ij(i,j)*c_ijkm(i,j,k,m)) + (w_ij(j,i)*c_ijkm(j,i,m,k))
end-do

! Vincolo (2)
sum(k in N) x_ik(k,k) = p

! Vincolo (3)
forall(i in N, k in N | i <> k) do
    x_ik(i,k) <= x_ik(k,k)
end-do

! Vincolo (4)
forall(i in N) do
    sum(k in N) (x_ik(i,k)) = 1
end-do

! Vincolo (5)
forall(i in N, k in N) do
    x_ik(i,k) <= 1       !Rilassamento vincolo binarietà
end-do

! Vincolo (7)
forall(i in N, k in N) do
    S_i(i) >= sum(j in N | j > i, m in N) (C_ijkm(i,j,k,m) * (x_ik(i,k) + x_ik(j,m) - 1))
end-do

forall(i in N) do
    S_i(i) >= 0
end-do

! Definizione della funzione obiettivo
obb := sum(i in N) (S_i(i))

forall(i in N, k in N) do
	xto0(i,k) := x_ik(i,k) = 0
	xto1(i,k) := x_ik(i,k) = 1
	sethidden(xto0(i,k),true)
	sethidden(xto1(i,k),true) 
end-do

! Definizione tempo massimo
setparam("XPRS_MAXTIME", 60)

inizio := time(SYS_NOW)

! Ricerca locale per migliorare la soluzione
! Primo ciclo per hub
flag := 1
while (flag = 1) do
    flag := 0
    minimize(obb)
    imax:=0
 	kmax:=0 
 	currentmax:= 0.0
    forall(i in N)do 
 		!codice che fissa a 0 e 1 le variabili che dopo il primo minimize sono gia' a 0 o 1
		if(getsol(x_ik(i,i))=0) then 
			sethidden(xto0(i,i), false)
		end-if
		if(getsol(x_ik(i,i))=1) then
			sethidden(xto1(i,i), false)
		end-if
		!codice che cerca le variabili continue con valore massimo per fissarle ad 1
		if(getsol(x_ik(i,i))>0 and getsol(x_ik(i,i))<1)then 
			flag:=1
			if(currentmax<getsol(x_ik(i,i))) then
				currentmax:=getsol(x_ik(i,i))
				imax:=i
			end-if
	 	end-if
	end-do
	if (flag=1) then
		sethidden(xto1(imax,imax), false)
	end-if
end-do

! Secondo ciclo per siti
flag := 1
while (flag = 1) do
    flag := 0
    minimize(obb)
    imax:=0
 	kmax:=0 
 	currentmax:= 0.0
    forall(i in N, k in N | i <> k)do 
 		!codice che fissa a 0 e 1 le variabili che dopo il primo minimize sono gia' a 0 o 1
		if(getsol(x_ik(i,k))=0) then 
			sethidden(xto0(i,k), false)
		end-if
		if(getsol(x_ik(i,k))=1) then
			sethidden(xto1(i,k), false)
		end-if
		!codice che cerca le variabili continue con valore massimo per fissarle ad 1
		if(getsol(x_ik(i,k))>0 and getsol(x_ik(i,k))<1)then 
			flag:=1
			if (getsol(x_ik(k,k))=1) then
				if(currentmax<getsol(x_ik(i,k))) then
					currentmax:=getsol(x_ik(i,k))
					imax:=i
					kmax:=k
				end-if
			end-if
	 	end-if
	end-do
	if (flag=1) then
		sethidden(xto1(imax,kmax), false)
	end-if
end-do

! Integer problem
forall(i in N, k in N) do
	x_ik(i,k) is_binary
end-do

sol_attuale := getobjval;
no_miglioramento := 0
writeln("La soluzione prima del while vale=", getobjval)

! Miglioramento
dimensione:=getsize(N) 
d := 6
! criterio di STOP: mi fermo dopo 5 cicli che non portano a miglioramenti della soluzione
while(no_miglioramento < 5) do 						 
	! genero sottoinsieme di variabili con random
	f := integer(round((dimensione*random)+0.5)) 
	if(f<=dimensione-d)then
		fminimo:=f
		fmassimo:=fminimo+d
	end-if
	if(f>=dimensione-d)then
		fmassimo:=f
		fminimo:=fmassimo-d
	end-if
	
	! reimposto vincoli 
	forall(i in N, k in N) do
		if (getsol(x_ik(i,k)) = 0) then
			sethidden(xto0(i,k), false)
			sethidden(xto1(i,k), true)
		end-if
		if (getsol(x_ik(i,k)) = 1) then
			sethidden(xto0(i,k), true)
			sethidden(xto1(i,k), false)
		end-if 
	end-do
	
	! rimuovo vincoli del sottoinsieme creato casualmente per cercare soluzione migliore
	forall(i in N, k in N | i>fminimo and i<fmassimo ) do
		sethidden(xto0(i,k),true)
		sethidden(xto1(i,k),true)
	end-do
	
	minimize(obb)
	
	writeln("---------------------------------------------------")
	writeln("La nuova soluzione vale: ", getobjval)
	
	if (getobjval < sol_attuale) then
		writeln("La soluzione trovata e' minore, quindi migliorata")
		sol_attuale := getobjval
		no_miglioramento := 0
		writeln("Azzero il numero di insuccessi")
	else 
		no_miglioramento := no_miglioramento + 1;
		writeln("La soluzione trovata e'  maggiore, quindi peggiorata")
		writeln( "Aumento il numero di non miglioramenti, adesso vale: ", no_miglioramento)
	end-if

end-do

fine := time(SYS_NOW) 
writeln(" run time= ",fine-inizio," ms ")
writeln(" la FO vale ", getobjval )

end-model
